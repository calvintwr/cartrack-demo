{"version":3,"sources":["configs/common.ts","components/Requestor/Timer.tsx","components/commons/Toggle.tsx","components/Requestor/Requestor.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["config","maxRequest","quotaWithin","Timer","props","timerInterval","state","timeLeft","calculateAndSetTimeLeft","this","setInterval","prevProps","timeOfReset","clearInterval","maxQuota","requestsRemaining","React","Component","self","difference","_calculateTimeLeft","reset","setState","now","Date","getTime","Math","round","Toggle","optionLabels","handleChange","e","checked","target","onChange","id","label","className","type","htmlFor","data-yes","data-no","Requestor","requestButtonText","clientDuration","clientMaxQuota","makeRequest","clientSideLimiter","clientRemaining","headers","ok","requestOngoing","fetch","mode","then","res","forEach","value","key","json","Error","message","console","log","totalRequests","serverMaxQuota","serverRemaining","serverTimeOfReset","calculateTimeOfReset","clientTimeOfReset","catch","err","alert","warn","finally","setTimeout","clientSideLimiterChange","resetClientQuota","resetServerQuota","disabled","onClick","xRateLimitReset","duration","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.235b0a1b.chunk.js","sourcesContent":["const config = {\n    maxRequest      : 5     // max number of requests before hitting 429 response\n    , quotaWithin   : 10    // within duration -- in seconds        \n}\nexport default config","import React from 'react'\n\ninterface Props {\n    timeOfReset?        : number | null\n    maxQuota            : number\n    requestsRemaining   : number\n    reset?              : Function\n}\n\ninterface State {\n    timeLeft: number\n}\n\nclass Timer extends React.Component<Props, State> {\n\n    timerInterval: undefined | NodeJS.Timeout\n\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            timeLeft: 0\n        }\n    }\n\n    componentDidMount() {\n        // start the timer\n        calculateAndSetTimeLeft(this)\n        // and set the interval to run down the timer by polling the time difference between now\n        // and the future timestamp (reset time)\n        this.timerInterval = setInterval(() => { calculateAndSetTimeLeft(this) }, 100)\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.props.timeOfReset === prevProps.timeOfReset) return\n\n        // clear old setInterval to prevent memory leak of having dereferenced setIntervals running simultaneously.\n        if(this.timerInterval) clearInterval(this.timerInterval)\n        this.timerInterval = setInterval(() => { calculateAndSetTimeLeft(this) }, 100)\n    }\n\n    componentWillUnmount() {\n        // clear all async operations when if component is unmounted\n        if(this.timerInterval) clearInterval(this.timerInterval)\n    }\n\n    render() {\n        const { timeLeft } = this.state\n        const { maxQuota, requestsRemaining } = this.props\n        return (\n            <span>\n                <p>Seconds to next reset: { timeLeft }</p>\n                <p>Requests limit: { maxQuota }</p>\n                <p>Requests remaining: { requestsRemaining }</p>\n            </span>\n        )\n    }\n\n}\n\nconst calculateAndSetTimeLeft = (self: Timer) => {\n\n    // only start the timer if timeOfReset is valid (not 0, null, undefined)\n    const difference = self.props.timeOfReset ? _calculateTimeLeft(self.props.timeOfReset) : 0\n    \n    // if the difference is below zero, it means we need to reset everything\n    if(difference <= 0) {\n        if(self.timerInterval) clearInterval(self.timerInterval)\n        if(self.props.reset) self.props.reset()\n        if(self.state.timeLeft !== 0) self.setState({ timeLeft: 0 })\n        return\n    }\n\n    self.setState({\n        timeLeft: difference\n    })\n\n}\n\nconst _calculateTimeLeft = (timeOfReset: number, now = new Date().getTime()) => {\n    const difference = timeOfReset - now\n    return Math.round(difference / 1000)\n}\n\nexport default Timer\nexport { Timer, calculateAndSetTimeLeft, _calculateTimeLeft }","import React from \"react\"\nimport \"./Toggle.scss\"\n\n/*\nToggle Switch Component\nNote: id, checked and onChange are required for ToggleSwitch component to function. The props name, small, disabled\nand optionLabels are optional.\nUsage: <ToggleSwitch id=\"id\" checked={value} onChange={checked => setValue(checked)}} />\n*/\n\ninterface Props {\n    id        : string\n    checked   : boolean\n    onChange  : Function\n    label     : string\n}\n\ninterface State {\n    checked: boolean\n}\n\nclass Toggle extends React.Component<Props, State> {\n\n    optionLabels = ['Yes', 'No']\n\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            checked: props.checked\n        }\n    }\n\n    handleChange = (\n        e: React.ChangeEvent<HTMLInputElement>\n            & { \n                target: {\n                    checked: boolean\n                }\n            }\n        ) => {\n        const checked = e.target.checked\n        this.setState({ checked })\n        this.props.onChange(checked)\n    }\n\n    render() {\n\n        const { id, label } = this.props\n        const { checked } = this.state\n\n        return (\n            <div className=\"toggle-outer\">\n\n                <div className=\"toggle\">\n\n                    <input\n                        type        = \"checkbox\"\n                        className   = \"toggle-checkbox\"\n                        id          = { id }\n                        checked     = { checked }\n                        onChange    = { this.handleChange }\n                    />\n\n                    <label\n                        className   = \"toggle-label\"\n                        htmlFor     = { id }\n                    >\n                        <span \n                            className   = \"toggle-inner\" \n                            data-yes    = { this.optionLabels[0] }\n                            data-no     = { this.optionLabels[1] }\n                        />\n\n                        <span className=\"toggle-switch\" />\n\n                    </label>\n\n                </div>\n\n                <label htmlFor={ id }>{ label }</label>\n\n            </div>\n            \n        )\n    }\n\n}\n\n\nexport default Toggle\n","import React from 'react'\nimport config from '../../configs/common'\nimport Timer from './Timer'\nimport Toggle from '../commons/Toggle'\n\ninterface Props {}\n\ninterface State {\n    totalRequests       : number\n\n    serverMaxQuota      : number\n    serverRemaining     : number\n    serverTimeOfReset?  : number | null\n\n    requestOngoing?     : boolean\n    requestButtonText   : string\n\n    // CLIENT-SIDE IMPOSED LIMITERS\n    // when server does not explicitly define rate limits\n    // or when you just want to limit your users \n    // because perhaps per API calls (especially to 3rd parties like Google Map) cost you money\n    clientRemaining     : number\n    clientTimeOfReset?  : number | null\n    clientSideLimiter   : boolean\n\n}\n\nclass Requestor extends React.Component<Props, State> {\n\n    requestButtonText   = 'Make Request'\n\n    // client side limiters\n    clientDuration      = (config.quotaWithin + 0.4)    // add 400ms to buffer race conditions\n    clientMaxQuota      = config.maxRequest\n    \n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            totalRequests       : 0\n            , serverMaxQuota    : 0\n            , serverRemaining   : 0\n            , requestButtonText : this.requestButtonText\n            , clientSideLimiter : false\n            , clientRemaining   : this.clientMaxQuota\n        }\n    }\n\n    componentDidMount() {\n        this.makeRequest() \n    }\n\n    makeRequest = () => {\n\n        if(this.state.clientSideLimiter && this.state.clientRemaining < 1) {\n            alert('[Client-side limiter] You run out of request quota. Please wait and try again later.')\n            return\n        }\n\n        const headers: any  = {}\n        let ok              = false\n\n        this.setState({\n            requestOngoing: true\n            , requestButtonText: 'Requesting...'\n        })\n    \n        return fetch('http://localhost:3000/', {\n            mode: 'cors'\n        }).then(res => {\n    \n            res.headers.forEach((value, key) => headers[key] = value)\n            ok = res.ok\n            return res.json()\n    \n        }).then(res => {\n    \n            if(!ok) throw Error(res.message)\n\n            console.log('%cBody:', 'color: green')\n            console.log(res)\n            console.log('%cHeaders', 'color: blue')\n            console.log(headers)\n\n            // RateLimit Headers (there are 2 kinds of specifications in use):\n\n            // IETF Draft Rate Limit standardisation (document \"draft-polli-ratelimit-headers-00\"):\n            // ratelimit-limit\n            // ratelimit-remaining\n            // ratelimit-reset\n\n            // Legacy/colloquial X-RATELIMIT headers\n            // x-ratelimit-limit\n            // x-ratelimit-remaining\n            // x-ratelimit-reset\n            \n            this.setState({\n                totalRequests       : this.state.totalRequests + 1\n                , serverMaxQuota    : headers['ratelimit-limit']\n                , serverRemaining   : headers['ratelimit-remaining']\n\n                // use an aggregated function to use `x-ratelimit-reset` or `ratelimit-reset` depending on which is available\n                , serverTimeOfReset : calculateTimeOfReset(headers['x-ratelimit-reset'], headers['ratelimit-reset'])\n            })\n\n            // client-side limiter\n            this.setState({\n                clientRemaining     : this.state.clientRemaining - 1\n            })\n            // need to check if the time of reset has passed to set a new one (thereby renewing the quota).\n            // else the quota is not renewed\n            if(!this.state.clientTimeOfReset || new Date().getTime() > this.state.clientTimeOfReset) {\n                this.setState({\n                    clientTimeOfReset : calculateTimeOfReset(null, this.clientDuration)\n                })                \n            }\n    \n        }).catch(err => {\n\n            alert(err)\n            console.warn(err)\n\n        }).finally(() => {\n\n            // #setTimeout is purely to simulate real world API lag\n            // else an API call to localhost will respond almost immediately\n            setTimeout(() => {\n                this.setState({\n                    requestOngoing      : false\n                    , requestButtonText : this.requestButtonText\n                })\n            }, 500)\n\n        })\n    }\n\n    clientSideLimiterChange = (checked: State['clientSideLimiter']) => {\n        this.setState({\n            clientSideLimiter: checked\n        })\n    }\n\n    resetClientQuota = (clientRemaining = this.clientMaxQuota) => {\n        this.setState({ clientRemaining })\n    }\n\n    resetServerQuota = (serverRemaining = this.state.serverMaxQuota) => {\n        this.setState({ serverRemaining })\n    }\n\n    render() {\n\n        const { \n            totalRequests\n            , serverMaxQuota\n            , serverRemaining\n            , serverTimeOfReset\n            , clientRemaining\n            , clientTimeOfReset\n            , clientSideLimiter\n            , requestOngoing\n            , requestButtonText\n        } = this.state\n\n        const { \n            makeRequest\n            , clientSideLimiterChange\n            , clientMaxQuota \n            , resetClientQuota\n            , resetServerQuota\n        } = this\n\n        return (\n            <div>\n\n                <article>\n                    <h2>Both server and client should impose rate limiting.</h2>\n                    <p>Client-side rate limiting blocks excessive requests at the earliest possible opportunity, \n                        saving network resources, or cuts unneccessary 3rd party API costs (e.g. Google Map).</p>\n                    <p>Server-side rate limit is the \"last line\" of defence, and can also mitigate DDoS to a certain extent.</p>\n                    <p>\n                        In the example below, you can toggle on and off the client-side rate limiter (server rate limit is always on). \n                        The slight difference in countdown between the two timers represents the server lag, or client/server clock differences. \n                    </p>\n                </article>\n                \n                <h1>Hello, you've made {totalRequests} request{ totalRequests > 1 ? 's' : ''} successfully.</h1>\n                <p>(See console for response body and headers)</p>\n\n                <button \n                    disabled    = { requestOngoing }\n                    onClick     = { makeRequest }\n                >{ requestButtonText }</button>\n\n                <Toggle \n                    id          = \"clientSideLimiter\"\n                    checked     = { clientSideLimiter } \n                    onChange    = { clientSideLimiterChange }\n                    label       = \"Use client-side rate limiter\"\n                />\n\n                { clientSideLimiter ? (\n                    <span>\n                        <h2>Client-side limiter (using client-side defined parameters)</h2>\n                        <Timer \n                            timeOfReset         = { clientTimeOfReset }\n                            maxQuota            = { clientMaxQuota }  \n                            requestsRemaining   = { clientRemaining }\n                            reset               = { resetClientQuota }\n                        />\n                    </span>\n                ) : (\n                    <span>\n                        <h2>Server-side rate limiter (using RateLimit Headers)</h2>\n                        <Timer \n                            timeOfReset         = { serverTimeOfReset }\n                            maxQuota            = { serverMaxQuota }  \n                            requestsRemaining   = { serverRemaining }\n                            reset               = { resetServerQuota }\n                        />\n                    </span>\n                )}\n                    \n            </div>     \n        )\n    }\n}\n\nconst calculateTimeOfReset = (\n    xRateLimitReset : number | null\n    , duration?     : number\n    , now           = new Date().getTime()\n) => {\n    if(xRateLimitReset) return xRateLimitReset * 1000\n    if(!duration) throw Error('`duration` must be defined if `xRateLimitReset` is not defined.')\n    return now + (duration * 1000)\n}\n\nexport default Requestor\nexport { Requestor, calculateTimeOfReset }","import './App.scss'\nimport Requestor from './components/Requestor/Requestor'\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <Requestor />\n            </header>\n        </div>\n    )\n}\n\nexport default App\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.scss'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}